a. That A' is a permutation of A. That is, A' contains all the elements of A in different order.
b. 
Loop Invariant
Every iteration of the inner for loop, A\[j] is the smallest value in A\[j : n].

Initialization
At the beginning of the loop j = n, so A\[j : n] is just A\[n]. Since A\[n] is the only value in the subarray, it is the smallest value in the subarray.

Maintenance
Suppose that just before this iteration, A\[j] is the smallest element of A\[j : n]. During the iteration, the algorithm compares the value of A\[j - 1] with the value of A\[j]. If A\[j - 1] > A\[j], it swaps A\[j - 1] and A\[j]'s positions. Otherwise nothing happens. In all cases, A\[j - 1] ends up being smaller than A\[j]. Since A\[j - 1] < A\[j] and A\[j] is the smallest element of A\[j : n], A\[j - 1] is also smaller than all of the elements of A\[j : n]. Therefore A\[j - 1] is the smallest element of A\[j - 1 : n]. Once j is decremented the loop invariant is still true.

Termination
Since the loop is a for loop, it always terminates once j has iterated down to i. As a result, A\[i] is the smallest element of subarray A\[i : n].

c.
Loop Invariant
Every iteration of the outer for loop, A\[1 : i - 1] is sorted and contains the i - 1 smallest elements of A.

Initialization
When the loop initializes, i = 1, so A\[1: i - 1] = A\[1 : 0] is empty and is therefore trivially sorted.

Maintenance
Assume that A\[1 : i - 1] is sorted and contains the i - 1 smallest elements of A before this iteration of the loop.

During this iteration of the loop, the inner for loop has this termination condition: A\[i] is the smallest element of subarray A\[i : n]. Since A\[1 : i - 1] already contained the i - 1 smallest elements of A, A\[i] must be greater than all the elements of A\[1 : i - 1]. As a result, when i is incremented, A\[1 : i - 1] is still sorted and still contains the i - 1 smallest elements of A.

Termination
When the loop terminates, i = n, so the subarray A\[1 : i - 1] is actually A\[1 : n - 1] and contains the n - 1 smallest elements in A in sorted order. As a result, A\[n] must be greater than all of the elements in A\[1 : n - 1]. From this, we know that A\[1 : n] is also sorted.

d. The worst-case running time of bubble-sort is O(n^2), which happens in every case. The outer for loop runs (n - 1) times. For every iteration of the outer for loop, the inner loop runs n, n - 1, n - 2, ..., 1 times.

In total, the inner loop runs n + (n - 1) + (n - 2) + ... + 1 times. We can get a formula for the total number of times the inner loop runs like this:

Add the biggest term and smallest term, n and 1, to get (n + 1). Add the second biggest and second smallest terms (n - 1) and 2, to get (n + 1). The ith biggest term can be written as n - (i - 1) and the ith smallest term as i.

If we add these two together, we get n - (i - 1) + i = n - i + 1 + i = n + 1. Since there are n terms in the original summation, by adding up pairs of them we will get n / 2 pairs of n + 1.

If n is an even number, then every number will have a pair and we will have n / 2 pairs of n + 1.
If n is an odd number, then the middle term will have no pair. Setting this middle term aside for a moment, we see that there are (n - 1) / 2 terms of n + 1, which gives a total of (n - 1)(n + 1) / 2

((n - 1)(n + 1) + (n + 1)) / 2
(n + 1)(n - 1 + 1) / 2
n(n + 1) / 2

n(n + 1) / 2 = 15

n = 5
1, 2, 3, 4, 5

(n + 1) + (n + 1) + (n + 1) / 2
(1 + 5) + (2 + 4) + 3